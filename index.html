<!DOCTYPE html>
<html>
<head>
    <title>WGL</title>
    <meta charset="utf-8">

    <style>
        * { padding: 0; margin: 0; box-sizing: border-box; }

        body { background-color: #000; }

        #renderer {
            width: 100%; height: 100%;
            position: absolute; top: 0px; bottom: 0px; left: 0px; right: 0px;
            border: 10px solid yellow;
            border-radius: 20px;
            background-color: #FFF;
        }
    </style>
</head>
<body>
    <canvas id="renderer"></canvas>

    <script src="gl-matrix.js"></script>
    <script src="gl.js"></script>
    <script src="api.js"></script>
    <script>
        const renderer = document.getElementById("renderer");

        renderer.onresize = function () {
            renderer.setAttribute("width", renderer.clientWidth);
            renderer.setAttribute("height", renderer.clientHeight);
        }

        renderer.onresize();


        const gl = renderer.getContext("webgl");

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        const vsSource = `
            attribute vec4 aVertexPosition;
            attribute vec4 aVertexColor;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uNormalMatrix;

            varying lowp vec4 vPosition;

            void main(void) {
                vPosition = uModelViewMatrix * aVertexPosition;
                gl_Position  = uProjectionMatrix * vPosition;
            }
        `;

        const fsSource = `
            varying lowp vec4 vPosition;

            void main(void) {
                gl_FragColor = vPosition * 0.5 + 0.5;
            }
        `;

        const shaderProgram = initShaderProgram(gl, vsSource, fsSource);


        const programInfo = {
            program: shaderProgram,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor')
            },
            uniformLocations: {
                projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix')
            }
        };


        const buffers = initBuffers(gl);

        const fieldOfView = 45 * Math.PI / 180;   // in radians
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const zNear = 0.1;
        const zFar = 100.0;
        const projectionMatrix = mat4.create();
        mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

        var modelViewMatrix = mat4.create();
        var normalMatrix = mat4.create();

        var then = 0;
        var cubeRotation = 0.0;

        // Draw the scene repeatedly
        function render(now) {
            now *= 0.001;  // convert to seconds
            const deltaTime = now - then;
            then = now;

            mat4.translate(modelViewMatrix, mat4.create(), [-0.0, 0.0, -10.0]);  // amount to translate

            cubeRotation += deltaTime;
            mat4.rotate(modelViewMatrix, modelViewMatrix, cubeRotation, [0, 0, 1]);
            mat4.rotate(modelViewMatrix, modelViewMatrix, 0.7 * cubeRotation, [0, 1, 0]);

            mat4.invert(normalMatrix, modelViewMatrix);
            mat4.transpose(normalMatrix, normalMatrix);

            drawScene(gl, programInfo, buffers, deltaTime);

            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);


    </script>
</body>
</html>