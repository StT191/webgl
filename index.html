<!DOCTYPE html>
<html>
<head>
    <title>WGL</title>
    <meta charset="utf-8">

    <style>
        * { padding: 0; margin: 0; box-sizing: border-box; }

        body { background-color: #000; }

        #renderer {
            width: 100%; height: 100%;
            position: absolute; top: 0px; bottom: 0px; left: 0px; right: 0px;
            border: 10px solid yellow;
            border-radius: 20px;
            background-color: #000;
        }
    </style>
</head>
<body>
    <canvas id="renderer"></canvas>

    <script src="gl-matrix.js"></script>
    <script src="dx.js"></script>
    <script src="animation-context.js"></script>
    <script src="gradedObject.js"></script>
    <script>
        // init

        const renderer = document.getElementById("renderer");
        const gl = renderer.getContext("webgl2");

        const dx = DX(gl);
        const ac = AnimationContext(gl);

        GradedShape.init(dx);
        gradedProgram.init(dx);


        // go

        ac.zoomWorld(-1000);
        ac.panWorld(9);
        ac.updateProjection();

        // shape

        var s = 100;
        var s0 = 0.25, s1 = 0.5, s2 = 1.0, s3 = 1.5;

        const y = [0,0], r = [1,0], g = [0,1], b = [1, 1];

        const c0 = [y, r, g];
        const c0r = [y, g, r];
        const c1 = [y, g, b];
        const c1r = [y, b, g];

        var shape0 = GradedShape(
            [
                [-s, -s,  s], [ s, -s,  s], [ s,  s,  s], [-s,  s,  s],
                [-s, -s, -s], [ s, -s, -s], [ s,  s, -s], [-s,  s, -s],
            ],
            [
                [
                    [255,  255,    0,  255], [255,    0,    0,  255],   // yellow, red
                    [  0,  255,    0,  255], [  0,    0,  255,  255]    // green, blue
                ],
                2, 2
            ],
            [
                [[0, 1, 2], c0], [[0, 2, 3], c1],    // front
                [[4, 6, 5], c0r], [[4, 7, 6], c1r],    // back
                [[0, 5, 1], c0r], [[0, 4, 5], c1r],    // bottom
                [[3, 2, 6], c0], [[3, 6, 7], c1],    // top
                [[0, 7, 4], c0r], [[0, 3, 7], c1r],    // left
                [[1, 6, 2], c0r], [[1, 5, 6], c1r],    // right
            ]
        );


        // drawing

        const {
            worldMatrix, cameraMatrix, perspectiveMatrix, projectionMatrix
        } = ac;

        var objMat = mat4.create();
        const pjMat = mat4.create();
        const nmMat = mat4.create();

        function draw (origin) {

            if (origin) mat4.multiply(pjMat,
                perspectiveMatrix,
                mat4.multiply(pjMat,
                    cameraMatrix,
                    mat4.multiply(pjMat,
                        mat4.getRotationMatrix(pjMat, worldMatrix),
                        objMat
                    )
                )
            );

            else mat4.multiply(pjMat, projectionMatrix, objMat);
            mat4.getRotationMatrix(nmMat, objMat);

            dx.draw(shape0, gradedProgram, {projectionMatrix: pjMat, normalMatrix: nmMat});
        }

        var cubeRotation = 0.0;

        ac.setRender(function (deltaAnimationTime) {

            cubeRotation += deltaAnimationTime / 1000; // in seconds

            dx.clear();

            // origin
            mat4.fromScaling(objMat, [0.03, 0.03, 0.03]);
            draw(true);

            mat4.fromTranslation(objMat, [0,0,750]);  // amount to translate
            mat4.rotate(objMat, objMat, cubeRotation, [0, 0, -1]);
            mat4.rotate(objMat, objMat, 0.7 * cubeRotation, [0, -1, 0]);
            mat4.rotate(objMat, objMat, 0.2 * cubeRotation, [1,  0, 0]);
            mat4.scale(objMat, objMat, [s0,s0,s0]);
            draw();

            mat4.fromTranslation(objMat, [0,0,250]);  // amount to translate
            mat4.rotate(objMat, objMat, cubeRotation, [0, 0, -1]);
            mat4.rotate(objMat, objMat, 0.7 * cubeRotation, [0, 1, 0]);
            mat4.rotate(objMat, objMat, 0.2 * cubeRotation, [-1, 0, 0]);
            mat4.scale(objMat, objMat, [s1,s1,s1]);
            draw();

            mat4.fromTranslation(objMat, [0,0,-250]);  // amount to translate
            mat4.rotate(objMat, objMat, cubeRotation, [0, 0, -1]);
            mat4.rotate(objMat, objMat, 0.7 * cubeRotation, [0, -1, 0]);
            mat4.rotate(objMat, objMat, 0.2 * cubeRotation, [1,  0, 0]);
            // mat4.scale(objMat, objMat, [s2,s2,s2]);
            draw();

            mat4.fromTranslation(objMat, [0,0,-750]);  // amount to translate
            mat4.rotate(objMat, objMat, cubeRotation, [0, 0, -1]);
            mat4.rotate(objMat, objMat, 0.7 * cubeRotation, [0, 1, 0]);
            mat4.rotate(objMat, objMat, 0.2 * cubeRotation, [-1, 0, 0]);
            mat4.scale(objMat, objMat, [s3,s3,s3]);
            draw();
        });

        ac.startAnimation();

    </script>
</body>
</html>