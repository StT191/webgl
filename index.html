<!DOCTYPE html>
<html>
<head>
    <title>WGL</title>
    <meta charset="utf-8">

    <style>
        * { padding: 0; margin: 0; box-sizing: border-box; }

        body { background-color: #000; }

        #renderer {
            width: 100%; height: 100%;
            position: absolute; top: 0px; bottom: 0px; left: 0px; right: 0px;
            border: 10px solid yellow;
            border-radius: 20px;
            background-color: #000;
        }
    </style>
</head>
<body>
    <canvas id="renderer"></canvas>

    <script src="gl-matrix.js"></script>
    <script src="dx.js"></script>
    <script>
        const rad = Math.PI / 180;
        // init

        const renderer = document.getElementById("renderer");
        const dx = DX(renderer.getContext("webgl2"));

        // matrix projection

        const worldMat = mat4.create();
        const cameraMat = mat4.fromTranslation(mat4.create(), [0, 0, -2000]);
        const perspectiveMat = mat4.create();
        const projMat = mat4.create();

        const tmpVec = vec3.create();
        const tmpQuat = quat.create();
        const tmpMat = mat4.create();

        const zeroVec = vec3.create();

        mat4.getRotationMatrix = function(out, mat) {
            return mat4.fromRotationTranslation(out, mat4.getRotation(tmpQuat, mat), zeroVec);
        }


        function project() {
            return mat4.multiply(projMat, perspectiveMat, mat4.multiply(tmpMat, cameraMat, worldMat));
        }

        // camera

        const dd = 50;

        function translateWorld(by) {
            return mat4.multiply(worldMat, mat4.fromTranslation(tmpMat, by), worldMat);
        }


        const da = 3*rad;

        function revolveWorld(by) {
            return mat4.multiply(worldMat, mat4.fromYRotation(tmpMat, by*da), worldMat);
        }

        function panWorld(by) {
            return mat4.rotateX(cameraMat, cameraMat, by*da);
        }

        function zoomWorld(by) {
            return mat4.multiply(cameraMat, mat4.fromTranslation(tmpMat, [0, 0, by]), cameraMat);
        }

        /*function rotateCam(axis) {
            translateWorld(vec3.negate(tmpVec, mat4.getTranslation(tmpVec, viewMat)));
            mat4.multiply(viewMat, mat4.fromRotation(tmpMat, da, axis), viewMat);
            translateWorld(vec3.negate(tmpVec, tmpVec));
            return viewMat;
        }*/

        zoomWorld(-20*dd);
        panWorld(8);

        // projection

        window.onresize = function () {
            const w = renderer.clientWidth;
            const h = renderer.clientHeight;

            renderer.setAttribute("width", w);
            renderer.setAttribute("height", h);

            dx.gl.viewport(0, 0, w, h);

            const fieldOfView = 20 * rad;   // in radians
            const aspect = w / h;
            const zNear = 1;
            const zFar = 2000000;
            mat4.perspective(perspectiveMat, fieldOfView, aspect, zNear, zFar);

            project();
            render(performance.now(), true);
        }


        // shape

        var s = 100;
        var s0 = 0.25, s1 = 0.5, s2 = 1.0, s3 = 1.5;

        const y = [0,0], r = [1,0], g = [0,1], b = [1, 1];

        const c0 = [y, r, g];
        const c0r = [y, g, r];
        const c1 = [y, g, b];
        const c1r = [y, b, g];

        var shape0 = dx.GradedShape(
            [
                [-s, -s,  s], [ s, -s,  s], [ s,  s,  s], [-s,  s,  s],
                [-s, -s, -s], [ s, -s, -s], [ s,  s, -s], [-s,  s, -s],
            ],
            [
                [
                    [255,  255,    0,  255], [255,    0,    0,  255],   // yellow, red
                    [  0,  255,    0,  255], [  0,    0,  255,  255]    // green, blue
                ],
                2, 2
            ],
            [
                [[0, 1, 2], c0], [[0, 2, 3], c1],    // front
                [[4, 6, 5], c0r], [[4, 7, 6], c1r],    // back
                [[0, 5, 1], c0r], [[0, 4, 5], c1r],    // bottom
                [[3, 2, 6], c0], [[3, 6, 7], c1],    // top
                [[0, 7, 4], c0r], [[0, 3, 7], c1r],    // left
                [[1, 6, 2], c0r], [[1, 5, 6], c1r],    // right

                /* [[0, 1, 2], c0], [[0, 2, 3], c1],    // front
                [[4, 5, 6], c0], [[4, 6, 7], c1],    // back
                [[0, 1, 5], c0], [[0, 5, 4], c1],    // bottom
                [[3, 2, 6], c0], [[3, 6, 7], c1],    // top
                [[0, 4, 7], c0], [[0, 7, 3], c1],    // left
                [[1, 2, 6], c0], [[1, 6, 5], c1],    // right*/
            ]
        );

        var objMat = mat4.create();

        // drawing
        var p = true;

        var then = 0;
        var cubeRotation = 0.0;

        function render(now) {
            if (!now) then = now = performance.now() * 0.001;
            else now *= 0.001;  // convert to seconds

            const deltaTime = now - then;
            then = now;

            cubeRotation += deltaTime;


            dx.clear();


            mat4.fromTranslation(objMat, [0,0,750]);  // amount to translate
            mat4.rotate(objMat, objMat, cubeRotation, [0, 0, -1]);
            mat4.rotate(objMat, objMat, 0.7 * cubeRotation, [0, -1, 0]);
            mat4.rotate(objMat, objMat, 0.2 * cubeRotation, [1,  0, 0]);
            mat4.scale(objMat, objMat, [s0,s0,s0]);
            dx.draw(shape0, projMat, objMat);

            mat4.fromTranslation(objMat, [0,0,250]);  // amount to translate
            mat4.rotate(objMat, objMat, cubeRotation, [0, 0, -1]);
            mat4.rotate(objMat, objMat, 0.7 * cubeRotation, [0, 1, 0]);
            mat4.rotate(objMat, objMat, 0.2 * cubeRotation, [-1, 0, 0]);
            mat4.scale(objMat, objMat, [s1,s1,s1]);
            dx.draw(shape0, projMat, objMat);

            mat4.fromTranslation(objMat, [0,0,-250]);  // amount to translate
            mat4.rotate(objMat, objMat, cubeRotation, [0, 0, -1]);
            mat4.rotate(objMat, objMat, 0.7 * cubeRotation, [0, -1, 0]);
            mat4.rotate(objMat, objMat, 0.2 * cubeRotation, [1,  0, 0]);
            // mat4.scale(objMat, objMat, [s2,s2,s2]);
            dx.draw(shape0, projMat, objMat);

            mat4.fromTranslation(objMat, [0,0,-750]);  // amount to translate
            mat4.rotate(objMat, objMat, cubeRotation, [0, 0, -1]);
            mat4.rotate(objMat, objMat, 0.7 * cubeRotation, [0, 1, 0]);
            mat4.rotate(objMat, objMat, 0.2 * cubeRotation, [-1, 0, 0]);
            mat4.scale(objMat, objMat, [s3,s3,s3]);
            dx.draw(shape0, projMat, objMat);

            if (p) requestAnimationFrame(render);
        }

        window.onresize();
        requestAnimationFrame(render);


        // keyboard mappings

        window.addEventListener("keydown", function (event) {
            switch(event.which) {
                case 65: translateWorld([-dd,   0,   0]); break; // a
                case 68: translateWorld([ dd,   0,   0]); break; // d
                case 87: translateWorld([  0,   0, -dd]); break; // w
                case 83: translateWorld([  0,   0,  dd]); break; // s
                case 81: translateWorld([  0,  dd,   0]); break; // q
                case 69: translateWorld([  0, -dd,   0]); break; // e

                case 74: revolveWorld(-1); break; // j
                case 76: revolveWorld( 1); break; // l
                case 73: panWorld(-1); break; // i
                case 75: panWorld( 1); break; // k
                case 85: zoomWorld(-dd); break; // u
                case 79: zoomWorld( dd); break; // o

                case 13: // Enter
                case 32: // Space
                case 80: if (p) p = false; else { p = true; render(); } break; // p

            }

            project();
            if (!p) render();
        });


        // mouse mappings

        function mousePan(event) {
            revolveWorld(event.movementX / 10);
            panWorld(event.movementY / 10);

            project();
            if (!p) render();
        }

        function toggleMousePan(direction, event) {
            if (event.button === 0) switch (direction) {
                case "down": window.addEventListener("mousemove", mousePan); break;
                case "up": window.removeEventListener("mousemove", mousePan); break;
            }
        }

        window.addEventListener("mousedown", toggleMousePan.bind(null, "down"));
        window.addEventListener("mouseup", toggleMousePan.bind(null, "up"));

        window.addEventListener("wheel", function (event) {
            zoomWorld(-event.deltaY * 50);
            project();
            if (!p) render();
        });


    </script>
</body>
</html>